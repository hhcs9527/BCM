import torch
import torch.nn as nn
# from torch.nn import init
import functools
# from torch.autograd import Variable
import random, time
import numpy as np
import cv2
import math
from itertools import chain 
from sub_modules.encoder_zoo import *
from sub_modules.decoder_zoo import *
from sub_modules.guide_feature_extractor import *
from sub_modules.alignment_zoo import *
from sub_modules.ConvLSTM_pytorch.convlstm import *


class motion_recurrent_fusion(nn.Module):
    '''
        when consider the offset, also the transformation on latent space (e.g. including convlstm, alignment)
        we execute those operations on motion latent feature.
    '''
    def __init__(self, opt):
        super().__init__()
        self.gf = Sharp_Distribution(opt)
        self.encoder = FPN_encoder(opt) 
        self.decoder = FPN_Decoder_SFT_fusion(opt)
        self.recurrent_time = opt.Recurrent_times
        self.alignment = PCD_alignment(opt)
        self.ConvLSTM = ConvLSTM(input_dim = opt.channel*4, hidden_dim=opt.channel*4, kernel_size=(3, 3), num_layers=2, batch_first=True, bias=True, return_all_layers=True)
        self.total_offset = torch.tensor(0.0).cuda()
        self.reproduce_blur = []
        self.alignment_deblur = []

    def generate_deblur(self, ef_lv1, ef_lv2, content_feature, input_, motion_feature):
        '''
            generate image with motion and encode feature.
        '''
        return self.decoder(content_feature, ef_lv2, ef_lv1, motion_feature, input_) + input_


    def generate_motion(self, motion_feature):
        '''
            use self.recurrent_time - 1 times of self.ConvLSTM
            return :
                self.motion_feature_list : [motion feature in timestamp 1, motion feature in timestamp 2, .., motion feature in timestamp 5]
        '''
        self.motion_feature_list = [motion_feature]
        hidden_state = None
        for i in range(self.recurrent_time - 1):
            motion = self.motion_feature_list[i]
            layer_outputs, hidden_state = self.ConvLSTM(torch.unsqueeze(self.motion_feature_list[i], 1), hidden_state)
            self.motion_feature_list.append(torch.squeeze(layer_outputs[0], 1))

    def generate_alignment_motion(self, motion_feature):
        '''
            use self.recurrent_time - 1 times of self.alignment
            return :
                1.  self.align_feature_list : [alignment motion feature in timestamp 1, alignment motion feature in timestamp 2, .., alignment feature in timestamp 5]
                    except timestamp 3, since timestamp 3 is the target latent
                2.  self.total_offset : alignment offset generated by PCD modules
        '''
        center_feature = self.motion_feature_list[self.recurrent_time//2]
        self.align_feature_list = []
        to_align_index = list(range(self.recurrent_time))
        to_align_index.remove(self.recurrent_time//2)

        for i in to_align_index:
            to_align_feature = self.motion_feature_list[i]
            align_feat, offsets = self.alignment(center_feature, to_align_feature)
            self.align_feature_list.append(align_feat)
            self.total_offset += offsets

    
    def generate_all(self, ef_lv1, ef_lv2, content_feature, input_, motion_feature):
        '''
            1. generate time-series -> align feature
            2. generate the deblur image for each stage
        '''
        self.reproduce_blur = []
        self.alignment_deblur = []

        for motion in self.motion_feature_list:
            self.reproduce_blur.append(self.generate_deblur(ef_lv1, ef_lv2, content_feature, input_, motion))

        for align in self.align_feature_list:
            self.alignment_deblur.append(self.generate_deblur(ef_lv1, ef_lv2, content_feature, input_, align))

    def forward(self, input):
        '''
            return 
                1.  content_feature : encode result of encoder
                2.  alignment_deblur : self.alignment_deblur
                3.  reproduce_blur : self.reproduce_blur (generate a series of sharp image, and average of them should look like input)
                4.  offset : self.total_offset
        '''
        motion_feature = self.gf(input)
        ef_lv1, ef_lv2, content_feature = self.encoder(input)

        self.generate_motion(motion_feature)
        self.generate_alignment_motion(motion_feature)

        self.generate_all(ef_lv1, ef_lv2, content_feature, input, motion_feature)
        
        return {'content_feature': content_feature, 'alignment_deblur':self.alignment_deblur, 'reproduce_blur':self.reproduce_blur, 'offset': self.total_offset}
